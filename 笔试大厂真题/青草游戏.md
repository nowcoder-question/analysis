## 题目
[题目链接](https://www.nowcoder.com/practice/ed0334a5e88f4662bb69374b308862d8?tpId=182&tqId=138080&sourceUrl=/exam/oj&channenl=wgithub&fromPut=wgithub)

#题解
##难度：中等
##知识点：博弈 求余

##博弈论：
二人或多人在平等的对局中各自利用对方的策略变换自己的对抗策略，达到取胜目标的理论。博弈论是研究互动决策的理论。博弈可以分析自己与对手的利弊关系，从而确立自己在博弈中的优势，因此有不少博弈理论，可以帮助对弈者分析局势，从而采取相应策略，最终达到取胜的目的。

如果使用递归，由于递推关系的依赖的状态太多，直接爆炸。

##本题思路：

###1.吃草规则的简化
吃4的整数次幂1、16、64、256、…，尾数有3种情况：1、4、6，模5之后只有1和4两种情况。即一次只能吃1 (mod 5) 或 4 (mod 5)数量的草。

###2.基于简化后的吃草规则，面对数量为R的草堆，应该怎么吃

面对R==0（mod 5）的情况，牛牛只能吃1（mod 5）或4（mod 5），因此牛牛吃完后，剩余的草量只能为1（mod 5）或4（mod 5），对于两种情况，羊羊都能在吃完之后使剩余数量为0（mod 5）。因此羊羊可以做到：使牛牛始终面临的草量都为 0（mod 5），其一种特殊情况即 0，因此这种情况牛牛必输。

面对R==1（mod 5）或R==4（mod 5）的情况，牛牛都可以把草的数量变为0（mod 5），而羊羊面对0（mod 5）的草堆必输，因此牛牛必赢。

面对R==2（mod 5）的情况，牛牛只能把草的数量变为1（mod 5）或者3（mod 5），此时他当然只能选择3（mod 5），如此羊羊可以选择吃1（mod 5）个草来使得R==2（mod 5)，因此羊羊可以做到：使牛牛始终面临的草量都为2（mod 5），其中特殊情况即2，因此牛牛必输。

面对R==3（mod 5）的情况，牛牛可以吃1（mod 5）个草，使得羊羊必输，因此牛牛必赢。

##因此可以得出：
R==0（mod 5）或R==2（mod 5）时牛牛必输；
R==1（mod 5）或R==3（mod 5）或R==4（mod 5）时，牛牛必赢。

```
#include<iostream>
using namespace std;
int main(){
	int t,n;
	cin&gt;&gt;t;
	for(int i=1;i&lt;=t;i++){
		cin&gt;&gt;n;
		if(n%5==0 || n%5==2) cout&lt;&lt;"yang"&lt;</iostream>